datasource db {
    provider          = "sqlserver"
    url               = env("DATABASE_URL")
    shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

generator client {
    provider = "prisma-client-js"
}

model User {
    id              String    @id @default(uuid())
    pubkey          String    @unique
    createdAt       DateTime
    isSystemUser    Boolean?  @default(false)
    fraudReportedAt DateTime?
    isSystemAgent   Boolean   @default(false)

    registrations    Registration[]
    userTokens       UserToken[]
    userLoginCode    UserLoginCode?
    userFraudOptions UserFraudOption[]
}

model UserToken {
    id         String   @id @default(uuid())
    userId     String
    deviceId   String
    token      String
    validUntil DateTime

    user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

    @@unique([userId, deviceId])
}

model UserFraudOption {
    id       String   @id @default(uuid())
    userId   String
    createAt DateTime

    user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model Registration {
    id             String    @id @default(uuid())
    userId         String
    identifier     String
    createdAt      DateTime
    validUntil     DateTime
    verifiedAt     DateTime?
    nipped         Int       @default(0)
    lastLookupDate DateTime?
    systemDomainId Int       @default(1)

    user                User                 @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
    registrationCode    RegistrationCode?
    registrationRelays  RegistrationRelay[]
    systemDomain        SystemDomain         @relation(fields: [systemDomainId], references: [id])
    registrationLookups RegistrationLookup[]

    @@unique([identifier, systemDomainId])
}

model RegistrationLookup {
    id             Int      @id @default(autoincrement())
    registrationId String
    date           DateTime
    total          Int

    registration Registration @relation(fields: [registrationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model DailyLookup {
    id     Int      @id @default(autoincrement())
    date   DateTime
    nipped Int
}

model RegistrationCode {
    id             String   @id @default(uuid())
    registrationId String   @unique
    code           String
    createdAt      DateTime
    validUntil     DateTime

    registration Registration @relation(fields: [registrationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model RegistrationRelay {
    id             String @id @default(uuid())
    registrationId String
    address        String

    registration Registration @relation(fields: [registrationId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model UserLoginCode {
    id         String   @id @default(uuid())
    userId     String   @unique
    code       String
    createdAt  DateTime
    validUntil DateTime

    user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model SystemConfig {
    id    Int    @id
    name  String
    value String
}

model SystemBlockedIdentifier {
    id   Int    @id @default(autoincrement())
    name String @unique
}

model SystemDomain {
    id            Int            @id
    name          String
    order         Int
    registrations Registration[]
}

// StatUsers has to be filled/triggered by "something from outside the Api"
// => Azure Function
model StatUser {
    id    Int      @id @default(autoincrement())
    date  DateTime
    users Int
}
